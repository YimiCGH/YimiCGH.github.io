---
layout: post
title: '在 Unity 中开发HTN Planner (5)'
excerpt: "Plan Runner开发，执行解决方案"
categories:
      - Dev Log
tags:
  - Log
  - Unity
  - AI
last_modified_at: 2019-12-03T16:30:00-23:00
---
{% include toc %}
---

## 计划执行器（Plan Runner）
从规划器得到解决方案后，会尝试按顺序执行每个行动，并把行动效果应用到世界状态上。如果任务执行失败，计划也会失败，并且强制规划器重新规划。因为在实际执行过程中，世界状态不在是静态的，收诸多因素的影响，可能会发生变化，导致计划中的某项行动的前提条件不在满足，从而任务失败。


简单的实现，暂不考虑其它功能
```lua
require "HTN.Core.Planner"

local PlanRunner = {}


function PlanRunner:DoPlan (_ws,_plan,_planer)
	for i, a in ipairs(_plan) do
		ApplyActionEffects(_ws,a)
	end
	--删除执行完毕后的世界状态
	PrintWorldState(_ws,0)
end

return PlanRunner
```

实际执行计划的过程中，需要考虑行动的执行条件是否满足，因为世界状态不像规划过程时那样是静态，相反，是无时无刻发生变化的，而且需要在执行失败后重新进行规划。

另外，行动的执行不是即时完成的，有些行动需要花时间完成，如移动，动画播放等。

还有就是可以给行动设置最大执行时间，超过执行时间则意味着执行失败。

## 下一步

准备扩展功能
- AI对世界的感知，如视觉，听觉
  - 为此，给AI提供感知器用来感知世界中某些信息
- AI短期记忆
  - 有种傻傻的AI，如一旦敌人离开视野，会马上回到巡逻，然后一看到敌人，又开始追击，因此，需要一种惯性来避免状态的来回切换。即，短期内，不会在回到该状态
- 多代理
  - 让尽可能多的代理智能体同时进行规划
  - 对于RPG这种，一个场景内能够支持100个智能体已经足够
  - 而对于RTS这种，动则上千单位，应该尽可能的分层设计
    - 如，由上层战略层进行宏观调控，个体Ai只进行一些简单Ai和上层指示的接受
- 调试器
  - 提供计划查看
  - 计划模拟
  - 运算消耗
